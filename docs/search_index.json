[["index.html", "Colorado State Forest (CSF) Adaptive Silviculture for Climate Change (ASCC) Planning Chapter 1 Objective", " Colorado State Forest (CSF) Adaptive Silviculture for Climate Change (ASCC) Planning George Woolsey 2023-03-23 Chapter 1 Objective The objective of this analysis is to describe the site conditions for the purpose of planning forest management activities at the Colorado State Forest (CSF) site for the Adaptive Silviculture for Climate Change (ASCC) project. This analysis quantifies the potential direct incident radiation and temperature at the site which will be utilized for planning the spatial arrangement of forest management treatments. "],["data_prep.html", "Chapter 2 Data Preparation 2.1 Explore Data 2.2 Treatment Area 2.3 Load Elevation Data 2.4 Aspect and HLI 2.5 HLI at different resolutions", " Chapter 2 Data Preparation # turn off the s2 processing ## https://stackoverflow.com/questions/68478179/how-to-resolve-spherical-geometry-failures-when-joining-spatial-data sf::sf_use_s2(FALSE) # set crs my_crs &lt;- 5070 # EPSG:5070 = NAD83/Conus Albers (units = meters); EPSG:4326 = WGS 84 (units = dd); EPSG:4269 = NAD83 (units = dd) 2.1 Explore Data The raster elevation data sent by Mark Melham (Mark.Melham@colostate.edu) was in a geodatabase (.gdb). GDAL uses the OpenFileGDB driver, which can only read vector data sources (here). Have to open .gdb in Arc and export as GeoTIFF (.tif). # read in elevation data exported from Arc as .tif elev_temp &lt;- terra::rast(&quot;../data/ground_elev_reproj.tif&quot;) # check values terra::summary(elev_temp) # appears that elevation is in ft...convert to m elev_temp &lt;- elev_temp/3.2808 # map elev_temp |&gt; terra::aggregate(fact=10, fun=&quot;mean&quot;) |&gt; as.data.frame(xy=T) |&gt; dplyr::rename(elevation=3) |&gt; ggplot() + geom_tile(mapping = aes(x=x,y=y,fill=elevation)) + scale_fill_viridis_c(option = &quot;cividis&quot;, label = scales::comma) + scale_x_continuous(expand = c(0.01, 0.01)) + scale_y_continuous(expand = c(0.01, 0.01)) + labs( fill = &quot;Elevation (m)&quot; ) + theme_light() + theme( legend.position = &quot;bottom&quot; , legend.direction = &quot;horizontal&quot; , legend.margin = margin(0,0,0,0) , legend.box.margin = margin(-7,0,2,0) , legend.text = element_text(size = 7, angle = 25, hjust = 0.7) , legend.title = element_text(size = 7) , axis.title = element_text(size = 7) , plot.subtitle = element_text(size=9) ) This elevation data is cropped to the unit boundaries. Need to get elevation raster extending outside unit boundaries to avoid edge effects when aggregating HLI values to a more coarse resolution (e.g. from 1m to 30m). Export treatment area bounding box to obtain USGS 3DEP 1m elevation data product. # set reproj crs reproject_crs &lt;- terra::crs(elev_temp) # export terra::ext(elev_temp) |&gt; terra::as.polygons() |&gt; sf::st_as_sf() |&gt; sf::st_set_crs(reproject_crs) |&gt; sf::st_buffer(dist = 500) |&gt; sf::st_bbox() |&gt; sf::st_as_sfc() |&gt; sf::st_write(&quot;../data/unit_bbox.shp&quot;, append = F) Upload this bounding box shape to Google Earth Engine and execute this script to get full USGS 3DEP 1m elevation data. 2.2 Treatment Area I don’t have the unit polygon data. Creating it from the boundary of the elevation raster which was cropped to the units. trt_units &lt;- elev_temp |&gt; terra::classify(rcl = (c(-Inf, Inf, 1) |&gt; matrix(ncol=3, byrow=TRUE)) ) |&gt; terra::as.polygons(trunc=TRUE, dissolve=TRUE) |&gt; sf::st_as_sf() |&gt; sf::st_set_crs(reproject_crs) 2.3 Load Elevation Data USGS 3DEP 1m resolution elevation data utilized for HLI calculation. ####################################################### ####################################################### # read elevation data ####################################################### ####################################################### elev &lt;- terra::rast(&quot;../data/csf_ascc_3dep1m.tif&quot;) |&gt; terra::crop( trt_units |&gt; sf::st_buffer(150) |&gt; sf::st_bbox() |&gt; sf::st_as_sfc() ) # plot ggplot() + geom_raster( data = elev |&gt; terra::aggregate(fact=10, fun=&quot;mean&quot;) |&gt; as.data.frame(xy=T) |&gt; dplyr::rename(elev=3) , mapping = aes(x=x,y=y,fill=elev) ) + geom_sf(data = trt_units, alpha = 0, lwd = 0.6, color = &quot;black&quot;) + scale_fill_viridis_c(option = &quot;cividis&quot;, label = scales::comma) + scale_x_continuous(expand = c(0.01, 0.01)) + scale_y_continuous(expand = c(0.01, 0.01)) + labs( fill = &quot;Elevation (m)&quot; , x = &quot;&quot; , y = &quot;&quot; ) + theme_light() + theme( legend.position = &quot;bottom&quot; , legend.direction = &quot;horizontal&quot; , legend.margin = margin(0,0,0,0) , legend.box.margin = margin(-7,0,2,0) , legend.text = element_text(size = 7, angle = 25, hjust = 0.7) , legend.title = element_text(size = 7) , axis.title = element_text(size = 7) , plot.subtitle = element_text(size=9) ) 2.4 Aspect and HLI Aspect of a slope (the direction or azimuth that a slope faces) strongly influences potential direct incident radiation and temperature. Untransformed, aspect is a poor variable for quantitative analysis, since 1° is adjacent to 360° – the numbers are very different even though the aspect is about the same. The following equation for Heat Load Index (HLI) rescales aspect to a scale of zero to one, with zero being the coolest slope (northeast) and one being the warmest slope (southwest). HLI is a proxy for aspect-driven solar heating. \\[ \\textrm{Heat load index} = \\frac{1 - \\cos(\\theta - 45)}{2} \\] where \\(\\theta\\) = aspect in degrees east of north. While this and related equations are useful, they do not consider the steepness of the slope. For example, a 1° south-facing slope would receive the same heat load index as a 30° south-facing slope, even though the latter will be considerably warmer. HLI calculations have been developed which combine slope, folded aspect (i.e., “southwestness”), and latitude to estimate terrain-driven solar heating at a given location (McCune &amp; Keon 2002: eq. 2). To calculate HLI, we used equation 2 of McCune &amp; Keon 2002: eq. 2. Following calculation, we aggregated these data to each group selection boundary (median HLI of ~6.8m pixels). Higher values of HLI are typical on steep southwesterly slopes, while low values are common on steep northeasterly slopes. Moderate values are common in flatter terrain and on northwesterly and southeasterly aspects. Aspect must first be “folded” about the north-south line, rescaling 0-360° to 0-180°, such that NE = NW, E = W, etc: \\[ \\textrm{Folded aspect°} = 180° \\, - \\, | Aspect° – 180° | \\] # convert elevation raster from terra to stars elev_stars &lt;- stars::st_as_stars(elev) |&gt; setNames(c(&quot;elev&quot;)) # extract latitude degrees from stars object lats &lt;- sf::st_coordinates(elev_stars) |&gt; sf::st_as_sf(coords = c(&quot;x&quot;, &quot;y&quot;), crs = my_crs) |&gt; sf::st_transform(crs = 4326) |&gt; sf::st_coordinates() |&gt; dplyr::as_tibble() |&gt; setNames(c(&quot;longitude&quot;,&quot;latitude&quot;)) |&gt; dplyr::select(latitude) gc() # hli function # This equation returns ln(Rad, MJ · cm–2 · yr–1). It can # be returned to an arithmetic scale with the EXP(x) # function. hli_fn &lt;- function(slope_rad, folded_aspect_rad, latitude_rad){ exp( (-1*1.236) + 1.350*cos(latitude_rad)*cos(slope_rad) + (-1*1.376)*cos(folded_aspect_rad)*sin(slope_rad)*sin(latitude_rad) + (-1*0.331)*sin(latitude_rad)*sin(slope_rad) + 0.375*sin(folded_aspect_rad)*sin(slope_rad) ) } # calculate slope and aspect from DEM topo &lt;- c( elev_stars , starsExtra::slope(elev_stars) , starsExtra::aspect(elev_stars) ) |&gt; setNames( c(&quot;elev&quot;, &quot;slope_deg&quot;, &quot;aspect_deg&quot;) ) |&gt; dplyr::mutate( slope_rad = pracma::deg2rad(as.numeric(slope_deg)) , aspect_rad = pracma::deg2rad(as.numeric(aspect_deg)) , folded_aspect_deg = 180 - abs(as.numeric(aspect_deg)-180) , folded_aspect_rad = pracma::deg2rad(folded_aspect_deg) , latitude_deg = lats$latitude , latitude_rad = pracma::deg2rad(as.numeric(latitude_deg)) , hli = dplyr::case_when( hli_fn(slope_rad, folded_aspect_rad, latitude_rad) &gt; 1 ~ 1 , hli_fn(slope_rad, folded_aspect_rad, latitude_rad) &lt; 0 ~ 0 , TRUE ~ hli_fn(slope_rad, folded_aspect_rad, latitude_rad) ) ) 2.4.1 Topography maps # map vars &lt;- c( &quot;elev&quot; , &quot;slope_deg&quot; , &quot;aspect_deg&quot; , &quot;folded_aspect_deg&quot; , &quot;hli&quot; ) vars_title &lt;- c( &quot;Elevation (m)&quot; , &quot;Slope (\\u00B0)&quot; , &quot;Aspect (\\u00B0)&quot; , &quot;Folded Aspect (\\u00B0)&quot; , &quot;Heat Load Index (HLI)&quot; ) vars_color &lt;- c( &quot;cividis&quot; , &quot;viridis&quot; , &quot;inferno&quot; , &quot;plasma&quot; , &quot;turbo&quot; ) vars_llim &lt;- c( min(topo$elev, na.rm=T)*.95 , 0 , 0 , 0 , 0 ) vars_ulim &lt;- c( max(topo$elev, na.rm=T)*1.05 , max(as.numeric(topo$slope_deg), na.rm=T)*1.05 , 360 , 180 , 1 ) # plts &lt;- list() plt_fn &lt;- function(x){ ( ggplot() + stars::geom_stars(data = (topo |&gt; dplyr::select(vars[x]))[]) + scale_fill_viridis_c(option = vars_color[x], alpha = 0.9, na.value = &quot;transparent&quot; , limits = c(vars_llim[x], vars_ulim[x]) , label = scales::comma ) + geom_sf(data = trt_units, alpha = 0, lwd = 0.6, color = &quot;black&quot;) + labs( subtitle = vars_title[x] , fill = vars_title[x] , x = &quot;&quot; , y = &quot;&quot; ) + scale_x_continuous(expand = c(0, 0)) + scale_y_continuous(expand = c(0, 0)) + theme_light() + theme( legend.position = &quot;bottom&quot; , legend.direction = &quot;horizontal&quot; , legend.margin = margin(0,0,0,0) , legend.box.margin = margin(-7,0,2,0) , legend.text = element_text(size = 7, angle = 25, hjust = 0.7) , legend.title = element_text(size = 7) , axis.title = element_text(size = 7) , plot.subtitle = element_text(size=9) ) ) } # print all plots c(1:length(vars)) |&gt; purrr::map(plt_fn) 2.5 HLI at different resolutions Aggregate HLI to different resolutions for use in selecting areas # create output dir if(!dir.exists(&quot;../data/output/&quot;)){ dir.create(&quot;../data/output/&quot;) } # function to map and output data hli_agg_fn &lt;- function(my_res = 50) { # base hli data and aggregate hli &lt;- terra::rast((topo |&gt; dplyr::select(hli))[]) |&gt; terra::aggregate(fact=my_res, fun=&quot;mean&quot;) # define quartile cuts cuts_list &lt;- c(.25, .5, .75) class_list &lt;- c(&quot;Coolest&quot;, &quot;Med. Cool&quot;, &quot;Med. Warm&quot;, &quot;Warmest&quot;) qrtl_cuts &lt;- terra::global(hli, fun = quantile, probs = cuts_list, na.rm = T) |&gt; as.numeric() # create matrix to reclassify cells based on quartile ## from-to-becomes # classify the values into three groups # all values &gt;= 0 and &lt;= 0.25 become 1, etc. rclmat_temp &lt;- c( 0, qrtl_cuts[1], 1 , qrtl_cuts[1], qrtl_cuts[2], 2 , qrtl_cuts[2], qrtl_cuts[3], 3 , qrtl_cuts[3], Inf, 4 ) |&gt; matrix(ncol=3, byrow=TRUE) # create raster with qrtl grps hli_qrtl &lt;- hli |&gt; terra::classify(rclmat_temp, include.lowest=TRUE) # plot plt_map &lt;- hli_qrtl |&gt; as.data.frame(xy=T) |&gt; dplyr::rename(hli=3) |&gt; dplyr::mutate( hli = factor( hli , labels = class_list , ordered = T )) |&gt; ggplot() + geom_raster(mapping = aes(x=x,y=y,fill=hli)) + scale_fill_viridis_d(option = &quot;turbo&quot;, alpha = 0.9, na.value = &quot;transparent&quot;) + geom_sf(data = trt_units, alpha = 0, lwd = 0.6, color = &quot;black&quot;) + labs( subtitle = paste0(&quot;Cell Size Resolution = &quot;, my_res, &quot;m x &quot;, my_res, &quot;m&quot;) , fill = &quot;&quot; , x = &quot;&quot; , y = &quot;&quot; ) + scale_x_continuous(expand = c(0, 0)) + scale_y_continuous(expand = c(0, 0)) + theme_light() + theme( legend.position = &quot;bottom&quot; , legend.direction = &quot;horizontal&quot; , legend.margin = margin(0,0,0,0) , legend.box.margin = margin(-7,0,2,0) , legend.text = element_text(size = 7) , legend.title = element_text(size = 7) , axis.title = element_text(size = 7) , plot.subtitle = element_text(size=9) ) # plot histogram plt_hist &lt;- dplyr::left_join( x = hli |&gt; as.data.frame(xy = T) |&gt; dplyr::rename(hli=3) , y = hli_qrtl |&gt; as.data.frame(xy = T) |&gt; dplyr::rename(hli_qrtl=3) , by = dplyr::join_by(x,y) ) |&gt; dplyr::mutate( hli_qrtl = factor( hli_qrtl , labels = class_list , ordered = T )) |&gt; ggplot() + geom_vline(xintercept = qrtl_cuts, color = &quot;gray65&quot;, lwd = 0.5, linetype = &quot;dashed&quot;) + geom_density( mapping = aes(x = hli, fill = hli_qrtl) , color = NA ) + facet_grid(hli_qrtl~.) + scale_fill_viridis_d(option = &quot;turbo&quot;, alpha = 0.95) + scale_x_continuous( limits = c( max( median(topo$hli, na.rm = T)-sd(topo$hli, na.rm = T)*2.5 , 0 ) ,1.01 ) , breaks = scales::extended_breaks(n=10) ) + labs( subtitle = paste0(&quot;Cell Size Resolution = &quot;, my_res, &quot;m x &quot;, my_res, &quot;m&quot;) # subtitle = &quot;HLI distribution by cool-warm site type&quot; , x = &quot;HLI&quot; , y = &quot;Density&quot; ) + theme_bw() + theme( legend.position = &quot;top&quot; , legend.title = element_blank() , axis.text.y = element_text(size = 7) , axis.text.x = element_text(size = 7, angle = 35, hjust = 0.7) , panel.border = element_blank() , plot.subtitle = element_text(size=9) ) # write terra::writeRaster(x = hli_qrtl, filename = paste0(&quot;../data/output/hli_qrtl_&quot;, my_res, &quot;m.tif&quot;), overwrite = T) terra::writeRaster(x = hli, filename = paste0(&quot;../data/output/hli_&quot;, my_res, &quot;m.tif&quot;), overwrite = T) # combine plots # print(plt_hist) # print(plt_map) return(list(plt_hist,plt_map)) } # call function with different resolutions res_list &lt;- c(10,25,50,100) plt_list &lt;- res_list |&gt; purrr::map(hli_agg_fn) 2.5.1 HLI Distributions Distribution by cool-warm site type at different cell size resolutions # plot histograms c(1:length(res_list)) |&gt; purrr::map( function(x){plt_list[[x]][[1]]} ) 2.5.2 HLI Maps Maps by cool-warm site type at different cell size resolutions # plot maps c(1:length(res_list)) |&gt; purrr::map( function(x){plt_list[[x]][[2]]} ) "],["404.html", "Page not found", " Page not found The page you requested cannot be found (perhaps it was moved or renamed). You may want to try searching to find the page's new location, or use the table of contents to find the page you are looking for. "]]
